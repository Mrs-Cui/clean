1. python 位操作 |, &与 ^:
    1) 按位与操作，只有 1 &1 为1，其他情况为0.
    2) |：按位或操作，只有 0|0为0，其他情况为1.
    3) ~：逐位取反。
    4) ^：异或，相同为0，相异为1。可用于加操作（不包括进位项）
2. python 进制表示:
    bin()  转2进制方法
    int()   转10进制方法
    oct()  转8进制方法
    hex()  转16进制方法
    1) 二进制: 0b
    2) 八进制: 0o
    3) 十六进制: 0x

3. fcntl:
    fcntl是计算机中的一种函数，通过fcntl可以改变已打开的文件性质。fcntl针对描述符提供控制。
    参数fd是被参数cmd操作的描述符。针对cmd的值，fcntl能够接受第三个参数int arg。
    fcntl的返回值与命令有关。如果出错，所有命令都返回－1，如果成功则返回某个其他值。
    int fcntl(int fd, int cmd);
　　 int fcntl(int fd, int cmd, long arg);
　　 int fcntl(int fd, int cmd, struct flock *lock);
    fcntl()针对(文件)描述符提供控制.参数fd 是被参数cmd操作(如下面的描述)的描述符.
　　 针对cmd的值,fcntl能够接受第三个参数int arg
    fcntl.FD_CLOEXEC:
        描述符设置了FD_CLOEXEC，使用execl执行的程序里，此描述符被关闭，不能再使用它，
        但是在使用fork调用的子进程中，此描述符并不关闭，仍可使用。
4. execl 执行程序:
    就是进程ID不变, 完全用另一个进程来替换当前进程.

python 命令参数详解:
    1. -b: 发出有关将bytearray与unicode比较的警告
    2. -B:
    3. -m: 将安装的第三方模块当作脚本来执行.
    4. -d:
    5. -E: 忽略PYTHON*等系统环境变量.
    6. -s: 不将当前目录加入到 sys.path


参考: http://baijiahao.baidu.com/s?id=1598055189738381758&wfr=spider&for=pc
    不过要明确一点，GIL不是Python的特性，它是Python的C解释器在实现的时候引入的特性，
    不是说我们的Python代码写出来就自带了GIL，而是在执行时，CPython解释器在解释多线程程序时会受到GIL锁的影响。
    python 全局性解释锁:
        1. GIL 解决了 python 中的什么问题?
            在多线程中对于跨线程分享的数据添加 GIL锁, 防止不一致的修改, 同时保证了数据的引用计数变量的安全。
            如果对每个对象/变量添加锁容易造成死锁(当有多个锁时), 重复的获取和释放锁会导致性能下降。GIL是解释器本身的
            一个单一锁, 规定任何python 字节码的执行都需要获取GIL。 因为只有一个锁所以不会造成死锁，也不会影响性能。
            但是这使得计算密集型任务变成了单线程。

        2. 为什么选用 GIL 作为解决方案?
            人们针对于C库中那些被Python所需的功能写了许多扩展，为了防止不一致变化，这些C扩展需要线程安全内存管理，而这些正是GIL所提供的。
            GIL是CPython开发者在早期Python生涯中面对困难问题的一种实用解决方案。

        3. GIL 对 多线程 python 程序的影响?
            在多线程版本中GIL阻止了计算密集型任务线程并行执行。
            GIL对I/O密集型任务多线程程序的性能没有太大的影响，因为在等待I/O时锁可以在多线程之间共享。
            但是对于一个线程是完全计算密集型的任务来说(例如，利用线程进行部分图像处理)不仅会由于锁而变成单线程任务而且还会明显的增加执行时间。
            这种执行时间的增加是由于锁带来的获取和释放开销。

        4. GIL 为什么没有被移除?

        5. python3 中 GIL 为什么没有被移除?

        6. 如何处理 python 中的 GIL?


python 线程锁:
    1. Lock:
        又叫原始锁, 只能获取锁一次, 但是允许在不同线程内释放锁.
    2. RLock:
        重用锁, 获取锁和释放锁必须成对出现, 而且必须在同一线程内进行获取和释放锁.

python 特殊方法:

    1. __getattribute__:
        实例调用属性时, 会调用该方法.
        当该方法与 __getattr__ 同时存在时, 只会调用__getattribute__, 除非该方法抛出异常,
        才会调用 __getattr__.

    2. __get__, __set__, __delete__:
        当一个类定义了 这三个中的任意一个就被称为数据描述符.
        定义了 __get__, __set__ 称为数据描述符.
        只定义了 __get__ 称为非数据描述符.
        属性查找优先级: 数据描述符 > dict > 非数据描述符
        当类中定义了 __setattr__, __setitem__, __getattribute__ 描述符类属性就失效了


unicode 编码:
    1. unicode 是一种字符集, 用码点来表示字符, 每个字符有唯一码点, 码点用十六进制表示.
    utf-8, utf-16, utf-32 在表示字符时采用的字节不同
    utf-32: 所有字符均采用4个字节.
    utf-16:
        编码有17个平面组成.
        第一平面区间范围: 0x0000 - 0xFFFF. 大部分常用字符都在该区间, 为二字节.
        剩余16个平面是由代理区间扩展来的, 采用 四字节:
        高代理区: D800-DBFF, 低代理区: DC00-DFFF
        代理区间由高代理区的头加上低代理区的尾组成.

    utf-8: 是一种变长编码方案, 有1, 2, 3,4四种字节组合.
        组合方式:
        0XXXXXXX:  一字节,
        110XXXXX 10XXXXXX: 二字节,
        1110XXXX 10XXXXXX 10XXXXXX: 三字节,
        11110XXX 10XXXXXX 10XXXXXX 10XXXXXX: 四字节
        通过字节最高位就能判断出属于哪个字节, 就能采用相应的字节模版.
