1. python 位操作 |, &与 ^:
    1) 按位与操作，只有 1 &1 为1，其他情况为0.
    2) |：按位或操作，只有 0|0为0，其他情况为1.
    3) ~：逐位取反。
    4) ^：异或，相同为0，相异为1。可用于加操作（不包括进位项）
2. python 进制表示:
    bin()  转2进制方法
    int()   转10进制方法
    oct()  转8进制方法
    hex()  转16进制方法
    1) 二进制: 0b
    2) 八进制: 0o
    3) 十六进制: 0x

3. fcntl:
    fcntl是计算机中的一种函数，通过fcntl可以改变已打开的文件性质。fcntl针对描述符提供控制。
    参数fd是被参数cmd操作的描述符。针对cmd的值，fcntl能够接受第三个参数int arg。
    fcntl的返回值与命令有关。如果出错，所有命令都返回－1，如果成功则返回某个其他值。
    int fcntl(int fd, int cmd);
　　 int fcntl(int fd, int cmd, long arg);
　　 int fcntl(int fd, int cmd, struct flock *lock);
    fcntl()针对(文件)描述符提供控制.参数fd 是被参数cmd操作(如下面的描述)的描述符.
　　 针对cmd的值,fcntl能够接受第三个参数int arg


python 命令参数详解:
    1. -b: 发出有关将bytearray与unicode比较的警告
    2. -B:
    3. -m: 将安装的第三方模块当作脚本来执行.
    4. -d:
    5. -E: 忽略PYTHON*等系统环境变量.
    6. -s: 不将当前目录加入到 sys.path


参考: http://baijiahao.baidu.com/s?id=1598055189738381758&wfr=spider&for=pc
    python 全局性解释锁:
        1. GIL 解决了 python 中的什么问题?
            在多线程中对于跨线程分享的数据添加 GIL锁, 防止不一致的修改, 同时保证了数据的引用计数变量的安全。
            如果对每个对象/变量添加锁容易造成死锁(当有多个锁时), 重复的获取和释放锁会导致性能下降。GIL是解释器本身的
            一个单一锁, 规定任何python 字节码的执行都需要获取GIL。 因为只有一个锁所以不会造成死锁，也不会影响性能。
            但是这使得计算密集型任务变成了单线程。

        2. 为什么选用 GIL 作为解决方案?
            人们针对于C库中那些被Python所需的功能写了许多扩展，为了防止不一致变化，这些C扩展需要线程安全内存管理，而这些正是GIL所提供的。
            GIL是CPython开发者在早期Python生涯中面对困难问题的一种实用解决方案。

        3. GIL 对 多线程 python 程序的影响?
            在多线程版本中GIL阻止了计算密集型任务线程并行执行。
            GIL对I/O密集型任务多线程程序的性能没有太大的影响，因为在等待I/O时锁可以在多线程之间共享。
            但是对于一个线程是完全计算密集型的任务来说(例如，利用线程进行部分图像处理)不仅会由于锁而变成单线程任务而且还会明显的增加执行时间。
            这种执行时间的增加是由于锁带来的获取和释放开销。

        4. GIL 为什么没有被移除?

        5. python3 中 GIL 为什么没有被移除?

        6. 如何处理 python 中的 GIL?
