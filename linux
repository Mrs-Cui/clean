Linux 命令
    常用工具命令:
        1. mkfs, 这是个危险的命令，mkfd 之后的任何命令都将被格式化。
        2. hostid: 打印当前主机的十六进制数字标识。是主机的唯一标识，是被用来限时软件的使用权限，不可改变。
        3. writer user 编号: 用于向指定登录用户终端上发送信息。 按EOF，输入结束。 如果接收信息的用户不只登入本地主机一次，你可以指定接收信息的终端机编号。
        4. mesg y/n: 设置当前终端的写权限，即是否让其他用户向本终端发信息。将mesg设置y时，其他用户可利用write命令将信息直接显示在您的屏幕上。
        5. clockdiff: 使用时间戳来测算目的主机和本地主机的系统时间差。
        6. screen:
        7. who: 显示目前登录系统的用户信息。单独执行who命令会列出登入帐号，使用的终端机，登入时间以及从何处登入或正在使用哪个X显示器。
            -H: 显示各栏位的标题信息列,
            -u: 若该用户在前一分钟之内有进行任何动作，将标示成"."号，如果该用户已超过24小时没有任何动作，则标示出"old"字符串
            -q: 只显示登入系统的帐号名称和总人数
            -w/--mesg: 显示信息状态栏。就是能否用write 发信息。

        8. ntpdate: 用来设置本地日期和时间.
        9. whatis: 用于查询一个命令执行什么功能，并将查询结果打印到终端上。
        10. login: 可用于重新登录或者切换用户身份。
        11. pssh: 可以在多台服务器上执行命令的工具，同时支持拷贝文件.
        12. stty: 修改终端命令行配置。
        13. ngrep:
        14. tempfile: 在shell 中创建临时文件。
        15. rsync: 远程同步文件。特点: 只传输文件的不同部分。
        16. find
    shell 内建命令:
        1. 在命令后 加 ‘&’, 可以将命令放到后台执行。
        2. w: 列出当前登录的用户，及其正在执行的进程。
        3. let: 简单的计算器
        4. type: 显示命令的类型.(别名，文件，函数，关键字，内建命令)
        5. unset: 删除指定环境变量。
        6. env: 显示当前的环境变量。
        7. alias: 设置命令别名.
        8. export: 设置/显示系统环境变量.
        9. fc: 用来修改/显示历史命令。
    系统安全:
        1. syslog: Linux系统默认的日志守护进程。默认的syslog配置文件是/etc/syslog.conf文件。
        程序，守护进程和内核提供了访问系统的日志信息。因此，任何希望生成日志信息的程序都可以向 syslog 接口呼叫生成该信息
        2. logwatch: 可定制和可插入式的日志监视系统，它通过遍历给定时间范围内的系统日志文件而产生日志报告.
        3. openssl: 一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，
        并提供丰富的应用程序供测试或其它目的使用
        4. logsave: 将命令输出的信息保存到指定文件中。
        5. lastb: 用于显示用户错误的登录列表，此指令可以发现系统的登录异常。
        单独执行lastb命令，它会读取位于/var/log目录下，名称为btmp的文件，并把该文件内容记录的登入失败的用户名单，全部显示出来。
        6. lastlog: 显示所有用户最近的登录信息。
        7. last: 用于显示用户最近登录信息。单独执行last命令，它会读取/var/log/wtmp的文件，
        并把该给文件的内容记录的登入系统的用户名单全部显示出来。

    进程和作业管理:
        1. watch: 以周期性的方式执行给定的指令，指令输出以全屏方式显示.
        2. pidof: 查找指定名称的进程的进程号id号。
        3. pgrep: 名称为依据从运行进程队列中查找进程，并显示查找到的进程id.
        4. renice: 修改正在运行的进程的调度优先级. 例:
        5. nohup: 将进程挂起运行，并将输出重定向到当前目录的nohup.out文件，如果指定了重定向文件咋输出到该文件。
        6. ipcs: 报告Linux中进程间通信设施的状态，显示的信息包括消息列表、共享内存和信号量的信息。
        7. nice: 用于以指定的进程调度优先级启动其他的程序。优先级: -19 ~ 19 例:
            nice -19 tar zcf pack.tar.gz documents。 注意: 此时 ‘-’ 只是前缀。
        8. pstree: 以树状图的方式展现进程之间的派生关系，显示效果比较直观。
        9. killall: 用进程名称杀死一组进程。
        10. ps: 报告当前系统进程的执行状态.
        11. pkill: 按照进程名杀死进程.
        12. at: 设定定时任务。
        13. crontab: 设定定时任务.
    网络应用:
        1. axel: 支持多线程下载、断点续传，且可以从多个地址或者从一个地址的多个连接来下载同一个文件.
        适合网速不给力时多线程下载提高下载速度。
        2. curl: 利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称curl为下载工具。
        3. wget: 从指定的URL下载文件.
        4. telnet: 用于登录远程主机，对远程主机进行管理。telnet因为采用明文传送报文，安全性不好.
        5. ipcalc: 简单的ip地址计算器，可以完成简单的IP地址计算任务。
    高级网络:
        1. ss: 显示处于活动状态的套接字信息.
        2. lnstat: 用来显示Linux系统的网路状态
        3. arptables: 用来设置、维护和检查Linux内核中的arp包过滤规则表.
        4. arpd: 用来收集免费arp信息的一个守护进程，它将收集到的信息保存在磁盘上或者在需要时，提供给内核用户用于避免多余广播。
        5. tcpdump: 是一款sniffer工具，它可以打印所有经过网络接口的数据包的头信息，也可以使用-w选项将数据包保存到文件中，方便以后分析。
        6. ip: 用来显示或操纵Linux主机的路由、网络设备、策略路由和隧道，是Linux下较新的功能强大的网络配置工具。
        7. tracepath: 用来追踪并显示报文到达目的主机所经过的路由信息。
        8. arpwatch: 用来监听网络上arp的记录。
        12. arp: 来管理系统的arp缓冲区，可以显示、删除、添加静态mac地址
        9. ping: 用来测试主机之间网络的连通性.
        ping 命令使用ICMP协议, 代理不会转发ICMP报文.
        ttl 值: linux 系统有默认ttl值, 数据包每经过一个路由器，TTL就会减1，当TTL为0时，这个数据包就会被丢弃。
        10. dig: 域名查询工具。
        11. nslookup: DNS 信息查询命令.
        12. iperf: 网络性能测试工具.
        13. traceroute: 追踪数据包在网络上的传输时的全部路径，它默认发送的数据包大小是40字节。
        14. netstat: 查看网络系统的状态信息。
    网络安全:
        1. ssh-copy-id: 可以把本地主机的公钥复制到远程主机的authorized_keys文件上，
        ssh-copy-id命令也会给远程主机的用户主目录（home）和~/.ssh, 和~/.ssh/authorized_keys设置合适的权限。
        2. ssh-agent: 一种控制用来保存公钥身份验证所使用的私钥的程序.
        3. ssh-add: 专用密钥添加到ssh-agent的高速缓存中.
        4. ssh-keygen: 用于为“ssh”生成、管理和转换认证密钥，它支持RSA和DSA两种认证密钥。
        5. ssh: SSH（Secure Shell Protocol）是一种网络协议，用于计算机之间的加密登录。
        在默认状态下SSH服务提供俩个服务功能，一个是提供类似telnet远程联机服务器的服务，即SSH服务，
        另一个是类似FTP服务的sftp-server，借助SSH协议来传输数据的，提供更安全的SFTP服务。
        提醒：SSH客户端（ssh命令）包含一个很有用的远程安全拷贝命令scp，也是通过ssh协议工作的。
    编程开发:
        1. pstack: 示每个进程的栈跟踪。pstack 命令必须由相应进程的属主或 root 运行。可以使用 pstack 来确定进程挂起的位置。
    性能检测与优化:
        1. ifstat: 统计网络接口活动状态的工具.
        2. dstat: 全能系统信息统计工具.
        3. tload: 图形化的方式输出当前系统的平均负载到指定的终端.
        4. lsof: 查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP).
        5. time: 统计给定命令花费时间的总和。
        6. fuser: 用于报告进程使用的文件和网络套接字.
        7. uptime: 打印系统总共运行了多长时间和系统的平均负载。uptime命令可以显示的信息显示依次为：
        现在时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的1分钟、5分钟和15分钟内的平均负载。
        8. iostat: 用于监视系统输入输出设备和CPU的使用情况.
        9. free: 内存使用情况.
        10. vmstat: 虚拟内存使用情况。
        11. sysctl: 用于运行时配置内核参数，这些参数位于/proc/sys目录下
        12. ulimit: 用来限制系统用户对shell资源的访问.
    文件:
        1. file: 查看文件类型.
        2. lsattr: 查看文件扩展属性.
        3. stat: 查看文件状态.

    1. top 查看进程状态。 文章: https://www.jianshu.com/p/3f19d4fc4538

Linux 进程之间的通信方式:
    进程通信应用场景:
        数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。
        共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。
        通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。
        资源共享：多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。
        进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。
    1. 管道:
        普通管道PIPE： 通常有两种限制,一是单工,只能单向传输;二是只能在父子或者兄弟进程间使用.
        流管道s_pipe: 去除了第一种限制,为半双工，只能在父子或兄弟进程间使用，可以双向传输.
        命名管道:name_pipe：去除了第二种限制,可以在许多并不相关的进程之间进行通讯.
    2. 信号量:
        信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。
        因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
    3. 消息队列:
        消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、
        管道只能承载无格式字节流以及缓冲区大小受限等缺点。
    4. 共享内存:
        共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，
        它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
    5. 套接字:
        套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。

Linux IO模式 及 epoll, poll, select 详解:

概念说明:
　   1、内核态（内核空间）和用户态（用户空间）的区别和联系？
　　　　用户空间是用户进程所在的内存区域，系统空间是操作系统所在的内存区域。
　　　　为了保证内核的安全，处于用户态的程序只能访问用户空间，而处于内核态的程序可以访问用户空间和内核空间。

　   3、缓存IO
　　　　Linux的缓存IO机制中，操作系统会将IO的数据缓存在文件系统的页缓存中，也就是说，数据会先被拷贝到操作系统内核的缓冲区，
       然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。
       缺点:
        数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。

    4. 用户空间与内核空间:
        现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）.
        操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限.
        为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。
        针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，
        而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。

    5. 进程的阻塞:
        正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等
        ,则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态.
        可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。
        当进程进入阻塞状态，是不占用CPU资源的.

    6.文件描述符:
        文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。
        文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。
        当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符

IO 模式:
刚才说了，对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。
所以说，当一个read操作发生时，它会经历两个阶段：
1. 等待数据准备
2. 将数据从内核拷贝到进程中.
正式因为这两个阶段，linux系统产生了下面五种网络模式的方案:
    1. 阻塞IO:
        当socket套接字调用recvfrom()接受数据时, kernel就开始了IO的第一个阶段: 准备数据(对于网络IO来说,很多数据在已开始还没有到达
        比如接收一个完整的UDP包, 这个时候kernel就需要等待数据的到来.). 这个过程时需要等待的. 对于用户进程来说,整个进程都被阻塞.
        当kernel 将数据准备好后,会将数据拷贝到用户进程内存中, kernel返回结果, 用户进程才重新运行起来.
        特点: IO执行的两个阶段都被block了。
    2. 非阻塞IO:
        当用户进程发起read操作时, 如果kernel 还没有准备好数据会立即返回 error. 对于用户进程来说时没有阻塞的. 当用户进程收到 error错误时,
        知道 kernel没有准备好数据, 就继续轮训发起 read操作. 当 kernel 准备好数据,并且又再次收到用户进程的system call，
        那么它马上就将数据拷贝到了用户内存，然后返回。
        特点:
            用户进程需要不断的主动询问kernel数据好了没有, 当数据从内核拷贝到进程中的时候会被阻塞.
    3. IO多路复用:
        select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，
        epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。
        当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，
        当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。
        所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）
        其中的任意一个进入读就绪状态，select()函数就可以返回。
        select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。
        实际中，对于每一个socket，一般都设置成为non-blocking，但是整个用户的process其实是一直被block的。
        只不过process是被select这个函数block，而不是被socket IO给block。
    4. 异步IO:

三 I/O 多路复用之select、poll、epoll详解:
    1. select:
        int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
        select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪
        （有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。
        当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。
        select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，
        可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。
    2. poll:
        不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。
        struct pollfd {
            int fd; /* file descriptor */
            short events; /* requested events to watch */
            short revents; /* returned events witnessed */
        };
        pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制
        （但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。
        事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。
    3. epoll:
        链接: https://segmentfault.com/a/1190000003063859?utm_source=tag-newest#articleHeader0
        相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，
        将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。

        epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，
        迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知。

        epoll的优点主要是一下几个方面：
            1. 描述符不受限制, 具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大.
            2. IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。
            只有就绪的fd才会执行回调函数。
    总结: 如果没有大量的idle -connection或者dead-connection，epoll的效率并不会比select/poll高很多，
    但是当遇到大量的idle- connection，就会发现epoll的效率大大高于select/poll。


linux 零拷贝技术:
    解决的问题: 将CPU从大量的数据拷贝任务中解脱出来, 主要是减少数据在用户空间和内核空间的拷贝.
    拷贝的操作需要四次用户模式和内核模式间的上下文切换，而且在操作完成前数据被复制了四次。
    具体见图:  zero_copy.gif

    上下文切换流程:  见 switch.gif
    1. read() 操作引发了第一次用户模式到内核模式的切换, 内核执行 sys_read(). 直接内存存取(DMA)执行了第一次拷贝, 将数据从磁盘拷贝到
    内核地址空间缓存区中.
    2. 所需要的数据从读取缓冲区拷贝到用户缓冲区, read()返回. 此时从内核模式切换到用户模式.
    3. send() 操作 再一次从用户模式到内核模式, 数据被拷贝到内核地址空间缓存区, 不过此时该缓存区与套接字有关.
    4. send() 返回. 从内核模式切换到用户模式, DMA引擎将数据从内核缓冲区传送到协议引擎.

    零拷贝技术:
    mmap:
        系统待用mmap()方法, 通过DMA技术将数据从磁盘拷贝到内核内存缓冲区, 系统会将这段内核缓冲区与应用程序共享,
        应用程序调用write()方法,将内核缓冲区的数据直接写入到socket缓冲区, 然后在再把数据发到网卡去。
        隐患:


linux 直接IO:

