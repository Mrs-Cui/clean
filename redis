redis 问题集:

1. redis为什么设计成单线程的?
    解: redis是基于内存的，CPU补时redis的性能瓶颈，Redis的性能瓶颈可能是机器内存及网络带宽。如果使用多线程不可避免的要使用锁。
    单线程无法发挥多核CPU的优势，可以在单机上多开几个实例。注: (单线程指的是在处理我们的网络请求的时候只有一个线程来处理,一个redis实例不止一个线程)

2. redis 字符串最大存储容量?
    512M

3. redis 各个数据类型最大存储数量?
    Lists类型：list的元素个数最多为2^32-1个，也就是4294967295个。
    Sets类型：元素个数最多为2^32-1个，也就是4294967295个。
    Hashes类型：键值对个数最多为2^32-1个，也就是4294967295个。
    Sorted sets类型：跟Sets类型相似。

4. Redis 持久化机制有哪些？区别是什么？
    如果同时使用 RDB 和 AOF 两种持久化机制，那么在 redis 重启的时候，会使用 AOF 来重新构建数据，因为 AOF 中的数据更加完整。

    RDB: RDB 持久化机制，是对 redis 中的数据执行周期性的持久化。(存储数据)
        优点:
            1. RDB会生成许多数据文件，每个数据文件都代表了某个时刻的Redis数据。该方式适合冷备，传输到安全的远程云服务器。
            2. RDB 对 Redis对外的读写服务影响非常小，可以让 redis 保持高性能，
            因为redis主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可
            3. 相对于AOF持久机制， 用RDB数据文件重启，恢复Redis数据更加快速。
        缺点:
            1. 在Redis故障时，尽量避免少丢失数据， RDB没有AOF做的好。因为RDB数据快照每隔五分钟做一次，甚至更长。
            2. RDB 每次在fork进程在生成快照文件时，如果数据文件过大会导致redis暂停服务数秒。
    AOF:AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，在
    redis 重启的时候，可以通过回放 AOF 日志中的写入指令来重新构建整个数据集。(存储命令)
        优点:
            1. AOF 可以很好的保证数据不被丢失，每隔一秒就会通过后台线程执行一次fsync操作，最多丢失一秒的数据。
            2. AOF 日志文件已 append-only方式写入，所以没有任何磁盘寻址开销。
            3. AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写.
            在 rewrite log 的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。
            在创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可。
            4. AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复.
        缺点:
            1.对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大。
            2.AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，
            因为 AOF 一般会配置成每秒 fsync 一次日志文件，当然，每秒一次 fsync，性能也还是很高的。
            3. 以前 AOF 发生过 bug，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。

5. Redis 缓存穿透，缓存雪崩，缓存击穿？解决方案?
    1. 缓存穿透:
        定义: 查询一个数据库一定不存在的数据.
        解释: 正常的使用缓存流程大致是，数据查询先进行缓存查询，如果key不存在或者key已经过期，
        再对数据库进行查询，并把查询到的对象，放进缓存。如果数据库查询对象为空，则不放进缓存。
        解决方案: 1. 在缓存中存放空值，并设置一个较短的过期时间。

    2. 缓存雪崩:
        定义: 在某一个时间段，缓存集中过期失效。
        解释: 比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网,
        而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。
        解决方案: 给键值随机设置过期时间，避免集中过期，给数据库造成压力。

    3. 缓存击穿:
        定义: 是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，
        当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。

6. Redis 缓存的更新策略有几种？分别有什么注意事项？
    1. LRU/LIRS/FIFO算法剔除:
        应用场景:
    2. 超时剔除
    3. 主动更新

7. 什么是分布式锁？有什么作用？
    1. 线程锁:
        主要用来给方法、代码块加锁。当某个方法或代码使用锁，在同一时刻仅有一个线程执行该方法或该代码段。

    2. 进程锁:
        为了控制同一操作系统中多个进程访问某个共享资源，因为进程具有独立性，各个进程无法访问其他进程的资源
        ，因此无法通过synchronized等线程锁实现进程锁。

    3. 分布式锁:
        当多个进程不在同一个系统中，用分布式锁控制多个进程对资源的访问。

    分布式锁的要求:
        1. 互斥性：任意时刻，只能有一个客户端获取锁，不能同时有两个客户端获取到锁。
        2. 安全性：锁只能被持有该锁的客户端删除，不能由其它客户端删除。
        3. 死锁：获取锁的客户端因为某些原因(如down机等)而未能释放锁，其它客户端再也无法获取到该锁。
        4. 容错：当部分节点(redis节点等)down机时，客户端仍然能够获取锁和释放锁。

8. redis 实现分布式锁:
    1. 加锁:
        加锁实际上就是在redis中，给Key键设置一个值，为避免死锁，并给定一个过期时间。
        SET lock_key random_value NX PX 5000
        值得注意的是：
        random_value 是客户端生成的唯一的字符串。
        NX 代表只在键不存在时，才对键进行设置操作。
        PX 5000 设置键的过期时间为5000毫秒。
        这样，如果上面的命令执行成功，则证明客户端获取到了锁。
    2. 释放锁:
        解锁的过程就是将Key键删除。但也不能乱删，不能说客户端1的请求将客户端2的锁给删除掉。这时候random_value的作用就体现出来。
        为了保证解锁操作的原子性，我们用LUA脚本完成这一操作。先判断当前锁的字符串是否与传入的值相等，是的话就删除Key，解锁成功。

9. Redis 通讯协议是什么？有什么特点？


10. Redis 的数据类型 SortedSet(zset) 以及底层实现机制？
    1. 底层的数据结构是跳跃表。
    2.

11. Redis 集群最大节点的数量:
    16384
    原因: redis 集群并没有使用一致性hash，而是引入了哈希槽的概念。
    Redis 集群有16384（2^14）个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。
    这种结构很容易添加或者删除节点，并且无论是添加删除或者修改某一个节点，都不会造成集群不可用的状态。

12. Redis 集群的主从复制模型介绍:
    1. 哨兵模式(单master节点):

    2. Redis-cluster 集群:

    3. 主从复制:

13. Redis 如何做内存优化？
    1. redisObject对象属性:
        理解 redis对象能帮助优化内存。
        1). encoding:
            表示Redis内部编码类型，encoding在Redis内部使用，代表当前对象内部采用哪种数据结构实现。
            理解Redis内部编码方式对于优化内存非常重要 ，同一个对象采用不同的编码实现内存占用存在明显差异.
        2). lru字段:
            记录对象最后一次被访问的时间，当配置了 maxmemory和maxmemory-policy=volatile-lru | allkeys-lru 时， 用于辅助LRU算法删除键数据。
            可以使用object idletime {key}命令在不更新lru字段情况下查看当前键的空闲时间
        3). *ptr字段:
            与对象的数据内容相关，如果是整数直接存储数据，否则表示指向数据的指针.
            高并发写入场景中，在条件允许的情况下建议字符串长度控制在39字节以内，减少创建redisObject内存分配次数从而提高性能。
    2. 缩减键值对象:
        1. value长度：值对象缩减比较复杂，常见需求是把业务对象序列化成二进制数组放入Redis。
        2. 值对象除了存储二进制数据之外，通常还会使用通用格式存储数据比如:json，xml等作为字符串存储在Redis中.
        在内存紧张的情况下，可以使用通用压缩算法压缩json,xml后再存入Redis.
        开发提示：当频繁压缩解压json等文本数据时，开发人员需要考虑压缩速度和计算开销成本，
        这里推荐使用google的Snappy压缩工具，在特定的压缩率情况下效率远远高于GZIP等传统压缩工具，且支持所有主流语言环境。

    3. 共享对象池:
        对象共享池指Redis内部维护[0-9999]的整数对象池
        需要注意的是对象池并不是只要存储[0-9999]的整数就可以工作。
        当设置maxmemory并启用LRU相关淘汰策略如:volatile-lru，allkeys-lru时，Redis禁止使用共享对象池.
        对于ziplist编码的值对象，即使内部数据为整数也无法使用共享对象池，因为ziplist使用压缩且内存连续的结构，对象共享判断成本过高.

    4. 字符串优化:
        字符串对象是Redis内部最常用的数据类型。所有的键都是字符串类型， 值对象数据除了整数之外都使用字符串存储.
        1. 字符串结构:
            SDS: int len: 已用字节长度， int free: 未使用字节长度， char buf: 字节数组。

            Redis自身实现的字符串结构有如下特点:

                1).O(1)时间复杂度获取：字符串长度，已用长度，未用长度。
                2).可用于保存字节数组，支持安全的二进制数据存储。
                3).内部实现空间预分配机制，降低内存再分配次数。
                4).惰性删除机制，字符串缩减后的空间不释放，作为预分配空间保留。
        2. 预分配机制:
            空间预分配规则如下:

                1) 第一次创建len属性等于数据实际大小，free等于0，不做预分配。
                2) 修改后如果已有free空间不够且数据小于1M，每次预分配一倍容量。
                如原有len=60byte，free=0，再追加60byte，预分配120byte，总占用空间:60byte+60byte+120byte+1byte。
                3) 修改后如果已有free空间不够且数据大于1MB，每次预分配1MB数据。
                如原有len=30MB，free=0，当再追加100byte ,预分配1MB，总占用空间:1MB+100byte+1MB+1byte。
                开发提示:尽量减少字符串频繁修改操作如append，setrange, 改为直接使用set修改字符串，降低预分配带来的内存浪费和内存碎片化。

        3. 字符串重构:
            设置配置， 让值采用ziplist编码。
    5. 编码优化:
        1. 了解编码:
            但是Redis内部针对不同类型存在编码的概念，所谓编码就是具体使用哪种底层数据结构来实现。编码不同将直接影响数据的内存占用和读写效率

            类型	      编码方式	                     数据结构
            string	  raw,embstr,int	             动态字符串编码,优化内存分配的字符串编码,整数编码
            hash	  hashtable,ziplist	             散列表编码,压缩列表编码
            list	  linkedlist,ziplist,quicklist	 双向链表编码,压缩列表编码,3.2版本新的列表编码
            set	      hashtable,intset	             散列表编码,整数集合编码
            zset	  skiplist,ziplist	             跳跃表编码,压缩列表编码
        2. 控制编码:
            编码类型转换在Redis写入数据时自动完成，这个转换过程是不可逆的，转换规则只能从小内存编码向大内存编码转换
            类型	    编码  	决定条件
            hash	ziplist	满足所有条件:  value最大空间(字节)<=hash-max-ziplist-value  field个数<=hash-max-ziplist-entries
            同上	  hashtable	满足任意条件:  value最大空间(字节)>hash-max-ziplist-value  field个数>hash-max-ziplist-entries
            list	ziplist	ziplist 满足所有条件:  value最大空间(字节)<=list-max-ziplist-value  链表长度<=list-max-ziplist-entries
            同上	linkedlist	满足任意条件  value最大空间(字节)>list-max-ziplist-value  链表长度>list-max-ziplist-entries
            同上	quicklist	3.2版本新编码:  废弃list-max-ziplist-entries和list-max-ziplist-entries配置  使用新配置:  list-max-ziplist-size:表示最大压缩空间或长度,最大空间使用[-5-1]范围配置，默认-2表示8KB,正整数表示最大压缩长度  list-compress-depth:表示最大压缩深度，默认=0不压缩
            set	intset	满足所有条件:  元素必须为整数  集合长度<=set-max-intset-entries
            同上	hashtable	满足任意条件  元素非整数类型  集合长度>hash-max-ziplist-entries
            zset	ziplist	满足所有条件:  value最大空间(字节)<=zset-max-ziplist-value  有序集合长度<=zset-max-ziplist-entries
            同上	skiplist	满足任意条件:  value最大空间(字节)>zset-max-ziplist-value  有序集合长度>zset-max-ziplist-entries

        3. ziplist 编码:
            压缩列表是 redis 为了节省内存开发的，时又一系列特殊编码的连续内存块组成的顺序结构。
            ziplist结构字段含义：
                1) zlbytes:记录整个压缩列表所占字节长度，方便重新调整ziplist空间。类型是int-32，长度为4字节
                2) zltail:记录距离尾节点的偏移量，方便尾节点弹出操作。类型是int-32，长度为4字节
                3) zllen:记录压缩链表节点数量，当长度超过216-2时需要遍历整个列表获取长度，一般很少见。类型是int-16，长度为2字节
                4) entry:记录具体的节点，长度根据实际存储的数据而定。
                    a) prev_entry_bytes_length:记录前一个节点所占空间，用于快速定位上一个节点，可实现列表反向迭代。
                    (注意: 当压缩列表中有值的改变后大于或小于512字节后会引发连锁更新, 删除元素也会。)
                    b) encoding:标示当前节点编码和长度，前两位表示编码类型：字符串/整数，其余位表示数据长度。
                    c) contents:保存节点的值，针对实际数据长度做内存占用优化。
                5) zlend:记录列表结尾，占用一个字节。
            根据以上对ziplist字段说明，可以分析出该数据结构特点如下:
                1) 内部表现为数据紧凑排列的一块连续内存数组。
                2) 可以模拟双向链表结构，以O(1)时间复杂度入队和出队。
                3) 新增删除操作涉及内存重新分配或释放，加大了操作的复杂性。
                4) 读写操作涉及复杂的指针移动，最坏时间复杂度为O(n2)。
                5) 适合存储小对象和长度有限的数据。
            开发提示：
                1）针对性能要求较高的场景使用ziplist，建议长度不要超过1000，每个元素大小控制在512字节以内。
                2）命令平均耗时使用info Commandstats命令获取，包含每个命令调用次数，总耗时，平均耗时，单位微秒

14. Redis 事务相关命令有哪些？
    1. MULTI: 用于开启一个事务，它总是返回OK。MULTI执行之后,客户端可以继续向服务器发送任意多条命令，
     这些命令不会立即被执行，而是被放到一个队列中
    2. EXEC: 负责触发并执行事务中的所有命令：
        如果客户端成功开启事务后执行EXEC，那么事务中的所有命令都会被执行。
        如果客户端在使用MULTI开启了事务后，却因为断线而没有成功执行EXEC,那么事务中的所有命令都不会被执行
       需要特别注意的是：即使事务中有某条/某些命令执行失败了，事务队列中的其他命令仍然会继续执行
    3. DISCARD: 事务会被放弃， 事务队列会被清空，并且客户端会从事务状态中退出
    4. WATCH: 被WATCH的键会被监视，并会发觉这些键是否被改动过了。
    如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消

15. 什么是 Redis 事务？原理是什么？

16. Redis 的批量命令与 Pipeline 有什么不同？
    1. multi, exec:
        multi指令的用途是保证multi和exec之间的所有指令不被其他客户端的指令打扰的一个个执行。
        服务端收到multi指令后，会一直等到exec指令到达，才将所有的指令一起放入队列执行。
    2. pipeline:
        如果指令很多，多到需要分多次发送到服务端，这时，pipeline不会等到所有指令到达后一起执行，而是收到一个包就执行这部分指令。

17. Redis 慢查询是什么？通过什么配置？
    1. slowlog 配置:
        `config get slowlog-log-slower-than`:
            查询log的时间阀值(微秒), 大于该数字的语句才会记录。负数表示不记录，0记录所有的.
        `config get slowlog-max-len`:
            查询log的最大条数。大于该数字，旧的会被丢弃。
    2. 慢查询定义:

18. Redis 的慢查询修复经验有哪些？怎么修复的？
    1. RDB 当数据文件过大时，在生成快照文件时会使服务暂停几秒种。

19. 可能导致 Redis 阻塞的原因?


20. 怎么去发现 Redis 阻塞异常情况？


21. 如何发现bigkey, 又什么影响？
    redis-cli --bigkeys， 工具: https://github.com/leonchen83/redis-rdb-cli
    影响:
        bigkeys 会导致redis 服务器性能降低。

22. 如何设置 Redis 的最大连接数？查看Redis的最大连接数？查看Redis的当前连接数？
    最大连接数:
        config get maxclients
    当前连接数:
        info clients

23. redis 性能优化分析:

    1. info 命令输出10个分类:
        server,clients,memory,persistence,stats,replication,cpu,commandstats,cluster,keyspace

    2.内存:
        used_memory是Redis使用的内存总量，包含了实际缓存占用的内存和Redis自身运行所占用的内存(如元数据、lua)，
        是由Redis使用内存分配器分配的内存，所以这个数据不包括内存碎片浪费掉的内存，其他字段代表的含义，都以字节为单位：
            1.used_memory_rss：从操作系统上显示已经分配的内存总量。
            2.mem_fragmentation_ratio： 内存碎片率。
            3.used_memory_lua： Lua脚本引擎所使用的内存大小。
            4.mem_allocator： 在编译时指定的Redis使用的内存分配器，可以是libc、jemalloc、tcmalloc。
        1、因内存交换引起的性能问题:
            内存使用率是Redis服务最关键的一部分。如果Redis实例的内存使用率超过可用最大内存 (used_memory > 可用最大内存)，
            那么操作系统开始进行内存与swap空间交换，把内存中旧的或不再使用的内容写入硬盘上（硬盘上的这块空间叫Swap分区），
            以便留出新的物理内存给新页或活动页(page)使用。

24. redis hashtable rehash:
    负载因子 = 哈希表已保存的节点数量/ 哈希表的大小。
    1. hashtable 是用链式链表解决冲突的。
    2. hashtable 的扩展:
        1). 当没有 bgsave或bgwriteaof 执行时，当负载因子 >= 1时。
        2). 当执行 bgsave或bgwriteaof 时， 负载因子 >= 5.
    3. 在 执行bgsave和 gbwriteaof 时，回提高负载因子，避免 在子进程执行 bgsave, bgwirteaof时， 主进程执行 hashtable rehash操作。

25. redis 过期键的删除策略:
    pass
