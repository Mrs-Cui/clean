
Data structure is king!

笔记：
    UDP / TCP:
        1. TCP socket makefile 与 socket 套接子的关系:
            用 makefile 创建文件描述符 就可以用文件描述符来操作
            代码如下:
                s, addrinfo = sock.accept()
                f = s.makefile(mode='rw')

                while True:
                    line = f.readline()  # read(10) 文本使用readline
                    logging.info(line)

                    if line.strip() == 'quit':
                        break

                    msg = "Your msg = {}. ack".format(line)
                    f.write(msg)
                    f.flush()
                f.close()
                sock.close()
            当 文件描述符关闭时，套接字不一定关闭， 除非调用套接字close 方法。
        2 listen backlog 可以指定TcpServer 同时接受客户端连接申请的数量, TcpServer 尽管可以接受N个客户端连接, 但是只能和网络栈第一个客户端
            进行通信。其余处于等待状态。



    数据结构:
        1. 树:

    参考: http://baijiahao.baidu.com/s?id=1598055189738381758&wfr=spider&for=pc
    python 全局性解释锁:
        1. GIL 解决了 python 中的什么问题?
            在多线程中对于跨线程分享的数据添加 GIL锁, 防止不一致的修改, 同时保证了数据的引用计数变量的安全。
            如果对每个对象/变量添加锁容易造成死锁(当有多个锁时), 重复的获取和释放锁会导致性能下降。GIL是解释器本身的
            一个单一锁, 规定任何python 字节码的执行都需要获取GIL。 因为只有一个锁所以不会造成死锁，也不会影响性能。
            但是这使得计算密集型任务变成了单线程。

        2. 为什么选用 GIL 作为解决方案?
            人们针对于C库中那些被Python所需的功能写了许多扩展，为了防止不一致变化，这些C扩展需要线程安全内存管理，而这些正是GIL所提供的。
            GIL是CPython开发者在早期Python生涯中面对困难问题的一种实用解决方案。

        3. GIL 对 多线程 python 程序的影响?
            在多线程版本中GIL阻止了计算密集型任务线程并行执行。
            GIL对I/O密集型任务多线程程序的性能没有太大的影响，因为在等待I/O时锁可以在多线程之间共享。
            但是对于一个线程是完全计算密集型的任务来说(例如，利用线程进行部分图像处理)不仅会由于锁而变成单线程任务而且还会明显的增加执行时间。
            这种执行时间的增加是由于锁带来的获取和释放开销。

        4. GIL 为什么没有被移除?

        5. python3 中 GIL 为什么没有被移除?

        6. 如何处理 python 中的 GIL?