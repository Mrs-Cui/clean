# 设计模式
## 代理模式
    定义: 在真实的操作实例前加一层代理，为其他对象提供代理以控制对这个对象的访问。
    
    案例: 1). 远程代理：在 web项目中引入应用程序引用，会在项目中自动生成相应的文件已方便调试。
         2). 虚拟代理: 根据需要创建开销很大的对象， 用其存放实例化需要很长时间的对象。
         3). 安全代理:
         4). 智能指引:

## 依赖倒转模式
    定义: 抽象不依赖细节, 细节依赖抽象。 顾名思义: 应该面向接口编程, 不应面向实现编程。有 松耦合，强内聚的效果。
        
## 单一职责原则
    定义:  把功能单一又多变的模块单独抽象出来。
    
## 工厂模式 VS 简单工厂模式
    简单工厂模式定义: 简单工厂模式需要在工厂类中添加逻辑判断, 需要根据用户的选择动态选择调用的类。
    工厂模式: 定义创建对象的接口， 让子类决定去实例化哪个对象。 
        优点: 降低了客户端程序与产品对象的耦合。
        
## 模板方法模式
    定义:  定义一个操作算法中的骨架， 将一些步骤延迟操作放到子类中。
    使用场景: 例如: 考卷的题目描述都是相同的，只有答题人的答案是不同的，因此可以把相同提出来创建父类， 提供答案接口给子类去继承。
    
## 迪米特法则
    定义:  别名又叫最少知识法则。 如果说两个类不必彼此直接发生通信，那么两个类就不应当直接相互作用，可以借助第三个类来转发调用。
    原则:  迪米特法则 强调的是在类的结构设计上，每个类都应该降低对属性的访问权限。每个类应当包装好自己的 private 属性。


## 创建者模式
    
    定义: 将一个复杂对象的创建和表示分离，那么同样的构建过程可以创建不同的表示。
    
    使用: 首先创建一个创建者父类，根据不同的表示继承父类创建子类。创建一个指挥者类， 目的将创建过程与表示分离。
    
## 观察者模式
    定义: 观察者模式又叫发布-订阅模式。 它 定义了一种一对多的关系，多个观察者对象同时关注一个主题对象，当主题对象发生变化时，就会通知
    所有的观察者，使它们能够自主更新。
    情景: 观察者模式 所作的工作就是解偶，让耦合的双方都依赖与抽象而不依赖于具体，从而使的各自的变化不会影响到另一方的变化。
    
    事件委托: 委托就是一种引用方法的类型，一旦为委托分配了方法，该委托将拥有和方法一样的行为。用委托的方法将主题对象与观察者解偶。
    
## 抽象工厂模式
    

## 状态模式
    定义: 当一个对象的内在状态改变时允许改变期行为，这个对象看起来像改变了其类。
    使用方式: 抽象一个状态类， 对于不同的状态创建状态子类。状态模式 把各种状态的逻辑分布到子类中。 减少了状态之间的相互依赖，方便扩展。

    
## 单例模式
     确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，单例模式是一种对象创建型模式
     
     理解: 单例模式就是由类自己控制实例的创建，并保证有唯一实例。
     
## 访问者模式
    目的: 将处理从数据结构中抽象出来，适合相对稳定的数据结构。
    理解: 有稳定的数据结构，又有易于变化的处理算法，用访问者模式比较好，访问者模式使得添加处理算法很方便。

## 责任链模式
    当客户端发出请求时，请求沿着责任链传递，直到有个Handler 能够处理这个请求。
    
## 命令模式
    定义: 将请求封装成一个对象，从而使用不同的请求对客户端进行参数化： 对请求排队，记录请求日志，以及可撤销操作。
    优点: 1. 比较容易设计命令队列。 2. 在需要的时候可以容易的将命令记录到日志。
         3. 允许执行命令的一方是否执行这个命令。 4. 可以很容易的撤销命令。
         5. 添加新的命令类不会影响到现有的命令类。
## 中介者模式
    定义:  用一个中介对象来封装一系列的对象交互。 中介者模式使对象之间不需要显示引用，降低了耦合性，可以独立改变它们之间的交互
    优点:  降低了交互对象间的耦合，可以独立改变和复用各个交互对象和中介者。
    缺点:  由于中介者控制了集中化，这就把交互复杂性变成了中介者的复杂性。 当交互对象多时，会使中介者变得无比复杂。

## 享元模式
    定义: 运用共享技术有效支持大量细粒度对象。
    内部状态: 在享元对象内部不会随环境变化而改变的属于内部状态。
    外部状态: 相反。
    应用场景: 某个程序因生成大量的对象产生了大量的内存开销可以考虑使用；大多数对象状态可以外部状态，排除外部状态后，
    如果可以用少量共享对象取代，可以考虑用共享模式。
    
## 适配器模式
    定义: 将一个类的接口转换成客户希望的接口. 适配器模式使得那些不能兼容，不能工作的类能一起工作。
    使用场景: 期望复用现存的类，但是接口与复用环境要求不一致的情况。
    适配器分为: 类适配模式，对象适配器模式

## 装饰模式
    
